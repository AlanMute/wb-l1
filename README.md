# WB Tech: level # 1

## Устные вопросы

### 1. Какой самый эффективный способ конкатенации строк?
   
   * Из-за того, что строки являются неизменяемыми, при их объединении создаются новые строки, что может привести к неэффективному использованию памяти, особенно при большом объеме операций.
     Поэтому в таких ситуациях более предпочтительно использовать strings.Builder. Это аналог bytes.Buffer, но при вызове метода String() не происходит повторного выделения памяти и копирования данных.
     В отличие от bytes.Buffer, у strings.Builder отсутствует оптимизация для небольших буферов и, следовательно, нет предварительно выделенной памяти для строки. Если не применять метод Grow, производительность будет ниже, чем у bytes.Buffer.
     
     ```
     a := "First string"
     b := "Second string"
     var sb strings.Builder

     sb.Grow(len(a)+len(b)) // Только тут выделяется память
     sb.WriteString(a)
     sb.WriteString(b)
     return sb.String()
     ```
     
### 2. Что такое интерфейсы, как они применяются в Go?

   * Интерфейс в программировании - это абстракция, которая определяет набор методов, которые должны быть реализованы в типе данных, чтобы удовлетворить этот интерфейс.
     Интерфейс не предоставляет реализации методов; он только определяет, какие методы должны быть в типе данных, который реализует интерфейс.
     Интерфейсы способствуют полиморфизму, что означает, что один и тот же интерфейс может использоваться для взаимодействия с разными типами данных, не зная о конкретных типах.
     Это позволяет создавать код, который способен обрабатывать разные типы данных через общий интерфейс, делая код более гибким и адаптивным к изменениям.
   * В Go если структура реализует все методы, объявленные в интерфейсе, и их сигнатуры полностью соответствуют сигнатурам методов интерфейса, то структура автоматически удовлетворяет этому интерфейсу.

### 3. Чем отличаются RWMutex от Mutex?

   * Mutex блокирует доступ к критической секции для всех других горутин(Lock() Unlock()).
     В то время как RWMutex есть еще 2 метода: RLock и RUnlock. Это позволяет нескольким горутинам одновременно получить доступ к критической секции для чтения данных из нее, не блокируя другие операции RLock RUnlock.

### 4. Чем отличаются буферизированные и не буферизированные каналы?

   * В небуферизированном канале операции чтения и записи блокирует текущую горутину. В свою очередь в буферизированном канале имеет буфер определенного размера, и горутина не блокируется до тех пор, пока этот буфер не заполнится.

### 5. Какой размер у структуры struct{}{}?

   * 0 байт

### 6. Есть ли в Go перегрузка методов или операторов?

   * В Go нет перегрузок методов и операторов. Можно лишь создавать структуры которые будут наследоваться от другой и создавать свои методы к ним.

### 7. В какой последовательности будут выведены элементы map[int]int?
