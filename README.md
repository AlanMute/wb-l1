# WB Tech: level # 1

## Устные вопросы

### 1. Какой самый эффективный способ конкатенации строк?
   
   * Из-за того, что строки являются неизменяемыми, при их объединении создаются новые строки, что может привести к неэффективному использованию памяти, особенно при большом объеме операций.
     Поэтому в таких ситуациях более предпочтительно использовать strings.Builder. Это аналог bytes.Buffer, но при вызове метода String() не происходит повторного выделения памяти и копирования данных.
     В отличие от bytes.Buffer, у strings.Builder отсутствует оптимизация для небольших буферов и, следовательно, нет предварительно выделенной памяти для строки. Если не применять метод Grow, производительность будет ниже, чем у bytes.Buffer.
     
     ```
     a := "First string"
     b := "Second string"
     var sb strings.Builder

     sb.Grow(len(a)+len(b)) // Только тут выделяется память
     sb.WriteString(a)
     sb.WriteString(b)
     return sb.String()
     ```
     
### 2. Что такое интерфейсы, как они применяются в Go?

   * Интерфейс в программировании - это абстракция, которая определяет набор методов, которые должны быть реализованы в типе данных, чтобы удовлетворить этот интерфейс.
     Интерфейс не предоставляет реализации методов; он только определяет, какие методы должны быть в типе данных, который реализует интерфейс.
     Интерфейсы способствуют полиморфизму, что означает, что один и тот же интерфейс может использоваться для взаимодействия с разными типами данных, не зная о конкретных типах.
     Это позволяет создавать код, который способен обрабатывать разные типы данных через общий интерфейс, делая код более гибким и адаптивным к изменениям.
   * В Go если структура реализует все методы, объявленные в интерфейсе, и их сигнатуры полностью соответствуют сигнатурам методов интерфейса, то структура автоматически удовлетворяет этому интерфейсу.

### 3. Чем отличаются RWMutex от Mutex?

   * Mutex блокирует доступ к критической секции для всех других горутин(Lock() Unlock()).
     В то время как RWMutex есть еще 2 метода: RLock и RUnlock. Это позволяет нескольким горутинам одновременно получить доступ к критической секции для чтения данных из нее, не блокируя другие операции RLock RUnlock.

### 4. Чем отличаются буферизированные и не буферизированные каналы?

   * В небуферизированном канале операции чтения и записи блокирует текущую горутину. В свою очередь в буферизированном канале имеет буфер определенного размера, и горутина не блокируется до тех пор, пока этот буфер не заполнится.

### 5. Какой размер у структуры struct{}{}?

   * 0 байт

### 6. Есть ли в Go перегрузка методов или операторов?

   * В Go нет перегрузок методов и операторов. Можно лишь создавать структуры которые будут наследоваться от другой и создавать свои методы к ним.

### 7. В какой последовательности будут выведены элементы map[int]int?

   * Мапа в Go unordered, то есть не упорядоченная. Это значит, что полагаться на порядок при обходе не надо.
     Однако начиная с версии 1.12 элементы будут выведены в порядке возрастания ключей. Это сделано для того, чтобы упрастить тестирование и обеспечения предсказуемости в работе с map.

### 8. В чем разница make и new?

   * Make используется для инициализации слайсов, мап и каналов. И в отличии от new, он не возвращает указатель на создоваемый тип, а возвращает само значение типа.
   * Функция new выделяет память - создает неименованную  нулевую переменную и возваращет указатель на ее значение.


### 9. Сколько существует способов задать переменную типа slice или map?

   * ```
     // slice
     var s []int
     s := []int{}
     s := []int{1, 2, 3}
     s := make([]int, 3)
     s := make([]int, 3, 3)
     s := new([]int)
     ```

   * ```
     // map

     var m map[int]string
     m := make(map[int]string)
     m := make(map[int]string, 3)
     m := new(map[int]string)
     m := map[int]string{
          1100: "Alan",
          2200": "Krizz",
     }
     ```

### 10. Что выведет данная программа и почему?

```
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```
   * Вывод программы:
     ```
     1
     1
     ```
     В функцию передали копию указателя. Оба указателя указывали изначально на один и тот же адрес, но после значение копии меняется. Это никак не повлияет на значения указателя p в main.

### 11. Что выведет данная программа и почему?

```
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```

   * Программа выведет числа от 0 до 4, но так же произойдет дедлок. Он произойдет, так как в функцию горутины необходимо передавать не копию структуры WaitGroupe, а указатель на нее.
     При изменении копии этой структуры и вызова метода Add(), структура в главной горутине не будет уменьшать свой счетчик, от чего главная горутина навсегда заблокируется в wg.Wait().

### 12. Что выведет данная программа и почему?

```
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```

   * Программа выведет ноль. Фигурные скобки, которые используется для if, создают новую область видимости в которой создается и увеличиватся новая переменная n. Но переменная n, созданная вне этой видимости изменятся не будет.

### 13. Что выведет данная программа и почему?

```
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```
```
Output:
[100 2 3 4 5]
```

   * В функцию передается копия среза, которая указывает на определенный массив. И при изменении первого элемента в копии среза, изменяется значении и в исходном срезе. Но при вызове функции append программа смотрит хватит ли ему емкости.
     В данном случае емкоссти не хватило, от чего выделалсь новая память под срез с большим copacity. И копия среза теперь указывает на новый созданный массив, от чего исходный срез не поменялся.

### 14. Что выведет данная программа и почему?

```
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```
```
Output:
[b b a][a a]
```
   * В данной программе вызывается анонимная функция в которую передается копия среза. После чего с помощью метода append(slice, "a") программа выделела новую память и копия среза начала указывать на новый массив. И уже в этом новом массиве меняются значения, которые никак не повлияют на исходный slice. 
     
